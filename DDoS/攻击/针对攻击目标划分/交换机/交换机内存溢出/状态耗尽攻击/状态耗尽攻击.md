# 基本情况
一种简单但有效的针对状态化SDN的攻击是通过不断扩展和更新交换机的状态表来使其饱和。实际上，虽然通常没有必要保留所有经过交换机的数据流的状态，但攻击者可以通过特定的应用程序巧妙地“迫使”这种行为发生，耗尽交换机的内存，从而导致内存饱和攻击。例如，在端口敲击和状态化UDP泛洪缓解的情况下就是如此。

## port knocking
a) 端口敲击攻击：

我们现在展示针对我们在第二节 D3 中介绍的端口敲击应用程序的一种攻击。

攻击者模型：

我们的端口敲击应用攻击考虑两种类型的攻击者：

    知情攻击者。 这类攻击者知道正确的端口敲击序列。此类信息可以通过多种方式获取，如监听流量；
    无知攻击者。 这类攻击者不知道确切的端口敲击序列。

考虑到这两种攻击者类型，我们接下来描述可能的内存饱和攻击。

知情攻击者场景：
假设A是一个知情攻击者。如图11所示，A向预定义序列中的第一个端口（即3306端口）发送大量连接尝试（即数据包），这些数据包来自一组伪造的IP地址，目标是交换机F。当F接收到一个源IP为例如1.2.3.4的数据包时，它会检查其状态表来检索传入流的状态。如果状态表中没有该IP地址的记录，则F会给对应的IP分配默认状态并执行XFSM表查找。由于所有传入的数据包都指向正确的端口，因此所有传入数据包（即相应的IP地址）的状态都将更新为下一个状态（即State 1：“3306端口被敲击”）。因此，交换机的状态表中会有大量的条目。这样，一个有意识的攻击者能够迫使生成数千条状态表记录，从而耗尽交换机的内存。

无知攻击者场景：
考虑A是一个无知攻击者的情况。在这种情况下，A可以通过从一组伪造的IP地址（例如IP属于D1 = [128.0.0.1 - 128.0.255.254]）向F的所有端口发送大量数据包来实施攻击，即从65535个伪造的IP地址发送65535个数据包（见图12）。假设之前没有使用过任何选定的IP地址，F将为所有相应的IP地址分配默认状态并执行XFSM表查找。值得注意的是，如果程序员因为不当实现而为每个流存储一个默认记录（即为每个传入流在表中分配一个记录），那么结果将是65535条状态表记录。如果攻击者继续向F的所有端口发送数据包，它将成功完成内存饱和攻击。然而，在“正确”的实现中，应该只有一个默认状态的记录。现在对于从IP 1.2.3.4来的传入数据包可能会发生以下两种情况：

    偶然地，A敲击了正确的端口（即3306端口）。在这种情况下，IP 1.2.3.4的状态将被更新为下一个状态（即State 1）；
    A没有敲击正确的端口，其状态保持为默认。在这种情况下，不需要保留IP 1.2.3.4的状态。

既然A可以轻松地定期执行数据包泛洪，她可以选择IP地址如下：

    选择一个不属于D1的IP：在这种情况下，她有机会敲击正确的端口，并且会在状态表中为正确的敲击端口用其中一个IP（例如IP 5.6.7.8）创建一个新的记录；
    选择一个属于D1的IP：如果她用IP 1.2.3.4敲击了一个错误的端口，根据[18]中所述，状态表中该IP的状态应改为默认。需要注意的是，如果我们有一个不仔细设计的实现，而不是覆盖状态表中的现有记录（实际上是将其从表中移除），交换机可能会为IP 1.2.3.4设置一个新的默认状态。

一旦攻击者利用了交换机的内存，交换机将无法处理新传入的数据包，这些数据包可能是由合法用户发出的。此时，交换机可能会采取以下行动之一：

    将数据包发送到控制器：在这种情况下，其行为与传统SDN相同；
    丢弃数据包：这会导致对合法用户的拒绝服务；
    覆盖状态表中的一个现有记录：问题在于如何选择要覆盖的记录。

为了应对随机端口扫描攻击，Bonola等人[28]提出了考虑一个新的状态，称为攻击状态。作者考虑了一个指标M1来计算主机使用的SYN速率。如果交换机检测到某个流正在进行端口扫描，则更新相应流的状态为“攻击状态”，阻止该主机两分钟，并触发警报。然而，这一解决方案无法缓解我们提出的内存饱和攻击。
## UDP flooding stateful Mitigation
b) 攻击UDP泛洪缓解措施：

在这里，我们展示了第二节 D5 中介绍的状态化UDP泛洪缓解应用对内存饱和攻击的脆弱性。

攻击场景：
正如第二节 D5 中解释的那样，SNAP为每个客户端发起的UDP数据包存储一个计数器以及客户端的当前状态，即客户端是否为UDP泛洪者。因此，如果攻击者从大量的不同IP地址发送UDP数据包，SNAP将为每个源IP地址分配一个状态变量和一个计数器。这样，攻击者能够轻易耗尽这些变量所占用的专用内存。

为了缓解此类攻击，人们可能会考虑为计数器和状态变量设置超时值。也就是说，如果交换机在预定的时间段内（即超时值）未接收到客户端H的任何UDP数据包，它可以释放分配给客户端H的内存空间。然而，“聪明”的攻击者可以定期发送UDP数据包，以迫使交换机保持相应主机的状态。